import sys
import subprocess
from pathlib import Path
from typing import List, Optional
from datetime import datetime

# Dependency Check & Auto-Install
def check_dependencies():
    """Checks and installs missing dependencies."""
    required = {"typer", "rich", "diskcache", "pathspec"}
    installed = set()
    
    try:
        import pkg_resources
        installed = {pkg.key for pkg in pkg_resources.working_set}
    except ImportError:
        # Fallback if pkg_resources is missing (unlikely in standard python envs)
        pass

    missing = required - installed
    
    # Try imports directly to be sure (pkg_resources can be slow or weird)
    try:
        import typer
        import rich
        import diskcache
        import pathspec
    except ImportError as e:
        print(f"Missing dependency: {e.name}")
        # If import fails, we definitely need to install
        # But we don't know exactly which one triggered it without parsing.
        # Simplest approach: Install requirements.txt if any import fails.
        install_requirements()
        # Restart the script
        print("Restarting script...")
        os.execv(sys.executable, [sys.executable] + sys.argv)

def install_requirements():
    """Installs dependencies from requirements.txt."""
    req_file = Path(__file__).parent / "requirements.txt"
    if req_file.exists():
        print(f"Installing dependencies from {req_file}...")
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", "-r", str(req_file)])
            print("Dependencies installed successfully.")
        except subprocess.CalledProcessError:
            print("Failed to install dependencies. Please run 'pip install -r requirements.txt' manually.")
            sys.exit(1)
    else:
        print("requirements.txt not found. Cannot auto-install dependencies.")
        sys.exit(1)

# Run check before importing 3rd party libs
import os
try:
    import typer
    from rich.console import Console
except ImportError:
    install_requirements()
    import typer
    from rich.console import Console

# Now import local modules
from common import console, PROJECT_ROOT, STRUCTURE_FILE, ERRORS_FILE, DOCS_DIR, ensure_docs_dir, ASSETS_DIR
from scanner import Scanner
from locker import Locker
from validator import Validator

app = typer.Typer(help="Project Steward CLI - The muscles of the operation.")

@app.command()
def scan():
    """Scans the codebase and updates docs/structure.md"""
    ensure_docs_dir()
    console.print("[bold blue]Scanning codebase...[/bold blue]")
    scanner = Scanner(PROJECT_ROOT)
    xml_content = scanner.scan()
    
    markdown_content = f"""# Project Structure

Generated by Project Steward at {datetime.now().isoformat()}

> **Note**: This file contains the recursive directory structure and descriptions of all files and core functions.

```xml
{xml_content}
```
"""
    STRUCTURE_FILE.write_text(markdown_content, encoding="utf-8")
    console.print(f"[green]Structure updated at {STRUCTURE_FILE}[/green]")

@app.command()
def roadmap(active: bool = False):
    """Displays the roadmap or current active task."""
    locker = Locker()
    if active:
        task = locker.get_active_task()
        if task:
            console.print(f"[bold green]Active Task:[/bold green] {task['name']} (ID: {task['id']})")
        else:
            console.print("[yellow]No active task found.[/yellow]")
    else:
        content = locker.roadmap_path.read_text(encoding="utf-8")
        console.print(content)

@app.command()
def lock(
    task: str = typer.Option(..., help="Task ID"),
    files: List[str] = typer.Option(..., help="List of files to lock")
):
    """Locks a task and associates files."""
    locker = Locker()
    locker.lock_task(task, files)

@app.command()
def commit(task: str = typer.Option(..., help="Task ID")):
    """Completes a task and unlocks files."""
    locker = Locker()
    locker.commit_task(task)

@app.command()
def add_task(
    title: str = typer.Option(..., help="Task title"),
    id: str = typer.Option(..., help="Unique Task ID"),
    parent: str = typer.Option(None, help="Parent Task ID (optional)")
):
    """Adds a new task to the roadmap."""
    locker = Locker()
    locker.add_task(title, id, parent)

@app.command()
def validate(file_path: Path):
    """Validates a file for docstrings."""
    validator = Validator()
    if not file_path.is_absolute():
        file_path = PROJECT_ROOT / file_path
    
    if file_path.exists():
        validator.validate(file_path)
    else:
        console.print(f"[red]File {file_path} does not exist.[/red]")

@app.command()
def log(
    scenario: str = typer.Option(..., help="When the error occurred"),
    error: str = typer.Option(..., help="The error description"),
    cause: str = typer.Option("Unknown", help="The analyzed cause"),
    files: List[str] = typer.Option([], help="Related file paths (relative)"),
    fix_plan: str = typer.Option("To be determined", help="Planned fix"),
    fix_result: str = typer.Option("Pending", help="Outcome of the fix"),
    notes: str = typer.Option("", help="Additional notes")
):
    """Logs a structured error entry to docs/errors.md (7-field format)."""
    ensure_docs_dir()
    timestamp = datetime.now().isoformat()
    files_str = ", ".join(files) if files else "None"
    
    entry = f"""
## Error Record {timestamp}

- **发生场景 (Scenario)**: {scenario}
- **报错描述 (Description)**: {error}
- **报错原因 (Cause)**: {cause}
- **关联目录文件组 (Related Files)**: {files_str}
- **修复方案 (Fix Plan)**: {fix_plan}
- **修复效果 (Fix Result)**: {fix_result}
- **注意事项 (Notes)**: {notes}

---
"""
    mode = "a" if ERRORS_FILE.exists() else "w"
    with open(ERRORS_FILE, mode, encoding="utf-8") as f:
        f.write(entry)
    
    console.print(f"[green]Structured error logged to {ERRORS_FILE}[/green]")

@app.command()
def memory(
    category: str = typer.Option("history", help="Category: user_summary, history, edit_history"),
    content: str = typer.Option(..., help="Content to append")
):
    """Appends information to docs/memory.md."""
    ensure_docs_dir()
    memory_file = DOCS_DIR / "memory.md"
    
    if not memory_file.exists():
        template = (ASSETS_DIR / "memory_template.md").read_text(encoding="utf-8")
        memory_file.write_text(template, encoding="utf-8")

    # Simple append strategy for now - in a real app, we might want to parse and insert under correct header
    # For now, we just append a log entry under the category header if we can find it, otherwise at bottom.
    
    file_content = memory_file.read_text(encoding="utf-8")
    
    header_map = {
        "user_summary": "## User Requirements Summary",
        "history": "## Conversation History Abstract",
        "edit_history": "## Edit History Abstract"
    }
    
    header = header_map.get(category, "## Other Memories")
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
    new_entry = f"\n- [{timestamp}] {content}"
    
    if header in file_content:
        # Insert after the header
        # Find the header and append after it (and any existing bullets)
        # This is a bit tricky with regex, let's just replace "## Header" with "## Header\n- content"
        # But we want to preserve order. Let's just append to the end of the section? 
        # Simplest valid approach: Append to end of file with a note, or simple string replace.
        
        # Strategy: Replace the header with Header + newline + content
        # This puts new items at the top of the section (stack like).
        file_content = file_content.replace(header, f"{header}{new_entry}")
    else:
        file_content += f"\n\n{header}{new_entry}"
        
    memory_file.write_text(file_content, encoding="utf-8")
    console.print(f"[green]Memory updated in {memory_file}[/green]")

if __name__ == "__main__":
    app()
